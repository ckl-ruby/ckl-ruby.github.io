<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构栈与队列笔记</title>
      <link href="/2022/04/18/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/18/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><hr><p>栈和队列与线性表的不同之处在于它们的插入和删除操作均受某种限制<br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_09-47-59.png" alt=""><br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_09-52-14.png" alt=""></p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>顺序栈的类型SqStack定义如下:</p><blockquote><p>typedef struct<br>{      ElemType data[MaxSize]；<br>        int top；        //栈顶指针<br>}  SqStack；</p></blockquote><h3 id="初始化栈InitStack-amp-s"><a href="#初始化栈InitStack-amp-s" class="headerlink" title="初始化栈InitStack(&amp;s)"></a>初始化栈InitStack(&amp;s)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;       s=(SqStack *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqStack));</span><br><span class="line">         s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="销毁栈DestroyStack-amp-s"><a href="#销毁栈DestroyStack-amp-s" class="headerlink" title="销毁栈DestroyStack(&amp;s)"></a>销毁栈DestroyStack(&amp;s)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">DestroyStack</span><span class="params">(SqStack *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断栈是否为空StackEmpty-s"><a href="#判断栈是否为空StackEmpty-s" class="headerlink" title="判断栈是否为空StackEmpty(s)"></a>判断栈是否为空StackEmpty(s)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">return</span>(s-&gt;top==<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进栈Push-amp-s，e"><a href="#进栈Push-amp-s，e" class="headerlink" title="进栈Push(&amp;s，e)"></a>进栈Push(&amp;s，e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack *&amp;s，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">if</span> (s-&gt;top==MaxSize<span class="number">-1</span>) <span class="comment">//栈满的情况，即栈上溢出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      s-&gt;top++;   <span class="comment">//栈顶指针增1</span></span><br><span class="line">      s-&gt;data[s-&gt;top]=e;   <span class="comment">//元素e放在栈顶指针处</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈Pop-amp-s，-amp-e"><a href="#出栈Pop-amp-s，-amp-e" class="headerlink" title="出栈Pop(&amp;s，&amp;e)"></a>出栈Pop(&amp;s，&amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack *&amp;s，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">if</span> (s-&gt;top==<span class="number">-1</span>)<span class="comment">//栈为空的情况，即栈下溢出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      e=s-&gt;data[s-&gt;top];<span class="comment">//取栈顶指针元素的元素</span></span><br><span class="line">      s-&gt;top--;<span class="comment">//栈顶指针减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取栈顶元素GetTop-s，-amp-e"><a href="#取栈顶元素GetTop-s，-amp-e" class="headerlink" title="取栈顶元素GetTop(s，&amp;e)"></a>取栈顶元素GetTop(s，&amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack *s，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　  <span class="keyword">if</span> (s-&gt;top==<span class="number">-1</span>)<span class="comment">//栈为空的情况，即栈下溢出    </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      e=s-&gt;data[s-&gt;top];<span class="comment">//取栈顶指针元素的元素</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>设计一个算法利用顺序栈判断一个字符串是否是对称串。所谓对称串是指从左向右读和从右向左读的序列相同。</p><blockquote><p>思路：字符串str的所有元素依次进栈，产生的出栈序列正好与str的顺序相反。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">symmetry</span><span class="params">(ElemType str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="type">int</span> i;  ElemType e; SqStack *st;</span><br><span class="line">     <span class="built_in">InitStack</span>(st);<span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;str[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)<span class="comment">//将串所有元素进栈</span></span><br><span class="line"><span class="built_in">Push</span>(st，str[i]);<span class="comment">//元素进栈</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>;str[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">     &#123;    <span class="built_in">Pop</span>(st，e);<span class="comment">//退栈元素e</span></span><br><span class="line">           <span class="keyword">if</span> (str[i]!=e) <span class="comment">//若e与当前串元素不同则不是对称串</span></span><br><span class="line">           &#123;     <span class="built_in">DestroyStack</span>(st);<span class="comment">//销毁栈</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">DestroyStack</span>(st); <span class="comment">//销毁栈</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>用一个数组实现两个栈，在两个栈中进栈元素时栈顶向中间扩展<br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_10-18-46.png" alt=""><br>共享栈类型DStack定义如下：</p><blockquote><p>typedef struct<br>{     ElemType data[MaxSize];    //存放共享栈中元素<br>       int top1，top2;        //两个栈的栈顶指针<br>} DStack;    </p></blockquote><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><blockquote><p>链栈中数据结点的类型LinkStNode定义如下:<br>typedef struct linknode<br>{     ElemType data;        //数据域<br>      struct linknode *next;    //指针域<br>}  LinkStNode;</p></blockquote><p>栈空条件：s-&gt;next=NULL<br> 栈满条件：不考虑<br> 进栈e操作：将包含e的结点插入到头结点之后<br> 退栈操作：取出头结点之后结点的元素并删除之</p><h3 id="初始化链栈"><a href="#初始化链栈" class="headerlink" title="初始化链栈"></a>初始化链栈</h3><p>建立一个空栈s。实际上是创建链栈的头结点，并将其next域置为NULL。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (LinkStNode *&amp;s)</span><br><span class="line">&#123;      s=(LinkStNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">        s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="销毁链栈"><a href="#销毁链栈" class="headerlink" title="销毁链栈"></a>销毁链栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyStack</span><span class="params">(LinkStNode *&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;　 LinkStNode *p=s，*q=s-&gt;next; <span class="comment">//p指向头结点，q指向首结点</span></span><br><span class="line">      <span class="keyword">while</span> (q!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;<span class="built_in">free</span>(p);</span><br><span class="line">p=q;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(p);<span class="comment">//此时p指向尾结点，释放其空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStNode *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>(s-&gt;next==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进栈Push-amp-s，e-1"><a href="#进栈Push-amp-s，e-1" class="headerlink" title="进栈Push(&amp;s，e)"></a>进栈Push(&amp;s，e)</h3><p>新建结点p用于储存e并将其插入到s后<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(LinkStNode *&amp;s，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;      LinkStNode *p;</span><br><span class="line">       p=(LinkStNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkStNode));</span><br><span class="line">       p-&gt;data=e;<span class="comment">//新建元素e对应的结点*p</span></span><br><span class="line">       p-&gt;next=s-&gt;next;<span class="comment">//插入*p结点作为开始结点</span></span><br><span class="line">       s-&gt;next=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="出栈Pop-amp-s，-amp-e-1"><a href="#出栈Pop-amp-s，-amp-e-1" class="headerlink" title="出栈Pop(&amp;s，&amp;e)"></a>出栈Pop(&amp;s，&amp;e)</h3><p>在栈不为空的条件下，将头结点后继数据结点的数据域赋给e，然后将其删除。对应算法如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LinkStNode *&amp;s，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     LinkStNode *p;</span><br><span class="line">      <span class="keyword">if</span> (s-&gt;next==<span class="literal">NULL</span>)<span class="comment">//栈空的情况</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      p=s-&gt;next;<span class="comment">//p指向开始结点</span></span><br><span class="line">      e=p-&gt;data;</span><br><span class="line">      s-&gt;next=p-&gt;next;<span class="comment">//删除*p结点</span></span><br><span class="line">      <span class="built_in">free</span>(p);<span class="comment">//释放*p结点</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LinkStNode *s，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="keyword">if</span> (s-&gt;next==<span class="literal">NULL</span>)<span class="comment">//栈空的情况</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       e=s-&gt;next-&gt;data;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>编写一个算法判断输入的表达式中括号是否配对（假设只含有左、右圆括号）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">char</span> exp[]，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> i=<span class="number">0</span>; <span class="type">char</span> e;  </span><br><span class="line"></span><br><span class="line">      <span class="type">bool</span> match=<span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">      LinkStNode *st;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">InitStack</span>(st);      <span class="comment">//初始化栈</span></span><br><span class="line">      <span class="keyword">while</span> (i&lt;n &amp;&amp; match)<span class="comment">//扫描exp中所有字符</span></span><br><span class="line">      &#123; </span><br><span class="line">            <span class="keyword">if</span> (exp[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">   <span class="built_in">Push</span>(st，exp[i]);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (exp[i]==<span class="string">&#x27;)&#x27;</span>) <span class="comment">//当前字符为右括号</span></span><br><span class="line">          &#123;      <span class="keyword">if</span> (<span class="built_in">GetTop</span>(st，e)==<span class="literal">true</span>)</span><br><span class="line">   &#123;    <span class="keyword">if</span> (e!=<span class="string">&#x27;(&#x27;</span>)   <span class="comment">//栈顶元素不为&#x27;(&#x27;时表示不匹配</span></span><br><span class="line">match=<span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line"><span class="built_in">Pop</span>(st，e);    <span class="comment">//将栈顶元素出栈</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>  match=<span class="literal">false</span>;  <span class="comment">//无法取栈顶元素时表示不匹配</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          i++;<span class="comment">//继续处理其他字符</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(st))</span><br><span class="line">match=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">DestroyStack</span>(st);     <span class="comment">//销毁栈</span></span><br><span class="line">      <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例题3-中缀表达式转后缀表达式并求值"><a href="#例题3-中缀表达式转后缀表达式并求值" class="headerlink" title="例题3 中缀表达式转后缀表达式并求值"></a>例题3 中缀表达式转后缀表达式并求值</h3><blockquote><p>思路：扫描exp的所有字符：数字字符直接放在postexp中,运算符通过一个栈来处理优先级</p></blockquote><p>(1)将算术表达式exp转换成后缀表达式postexp<br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-12-25.png" alt=""><br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-10-48.png" alt=""><br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-15-43.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">char</span> *exp，<span class="type">char</span> postexp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">char</span> e;  </span><br><span class="line">       SqStack *Optr;<span class="comment">//定义运算符栈指针</span></span><br><span class="line">       <span class="built_in">InitStack</span>(Optr);<span class="comment">//初始化运算符栈</span></span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//i作为postexp的下标</span></span><br><span class="line">       <span class="keyword">while</span> (*exp!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//exp表达式未扫描完时循环</span></span><br><span class="line">       &#123; <span class="keyword">switch</span>(*exp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:<span class="comment">//判定为左括号</span></span><br><span class="line">         <span class="built_in">Push</span>(Optr，<span class="string">&#x27;(&#x27;</span>);<span class="comment">//左括号进栈</span></span><br><span class="line">         exp++;<span class="comment">//继续扫描其他字符</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:    <span class="comment">//判定为右括号</span></span><br><span class="line">        <span class="built_in">Pop</span>(Optr，e);    <span class="comment">//出栈元素e</span></span><br><span class="line">        <span class="keyword">while</span> (e!=<span class="string">&#x27;(&#x27;</span>)    <span class="comment">//不为&#x27;(&#x27;时循环</span></span><br><span class="line">        &#123;  postexp[i++]=e;    <span class="comment">//将e存放到postexp中</span></span><br><span class="line">  <span class="built_in">Pop</span>(Optr，e);    <span class="comment">//继续出栈元素e</span></span><br><span class="line">         &#125;</span><br><span class="line">         exp++;     <span class="comment">//继续扫描其他字符</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//判定为加或减号</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">              <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(Optr))<span class="comment">//栈不空循环</span></span><br><span class="line">&#123;        <span class="built_in">GetTop</span>(Optr，e);<span class="comment">//取栈顶元素e</span></span><br><span class="line">          <span class="keyword">if</span> (e!=<span class="string">&#x27;(&#x27;</span>)<span class="comment">//e不是&#x27;(&#x27;</span></span><br><span class="line">          &#123;      postexp[i++]=e;<span class="comment">//将e存放到postexp中</span></span><br><span class="line">   <span class="built_in">Pop</span>(Optr，e);<span class="comment">//出栈元素e</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//e是&#x27;(时退出循环</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">Push</span>(Optr，*exp);<span class="comment">//将&#x27;+&#x27;或&#x27;-&#x27;进栈</span></span><br><span class="line">exp++;<span class="comment">//继续扫描其他字符</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="comment">//判定为&#x27;*&#x27;或&#x27;/&#x27;号</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(Optr))<span class="comment">//栈不空循环</span></span><br><span class="line">        &#123;     <span class="built_in">GetTop</span>(Optr，e);<span class="comment">//取栈顶元素e</span></span><br><span class="line"><span class="keyword">if</span> (e==<span class="string">&#x27;*&#x27;</span> || e==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#123;       postexp[i++]=e;<span class="comment">//将e存放到postexp中</span></span><br><span class="line">        <span class="built_in">Pop</span>(Optr，e);<span class="comment">//出栈元素e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//e为非&#x27;*&#x27;或&#x27;/&#x27;运算符时退出循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">Push</span>(Optr，*exp);<span class="comment">//将&#x27;*&#x27;或&#x27;/&#x27;进栈</span></span><br><span class="line">         exp++;<span class="comment">//继续扫描其他字符</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//处理数字字符</span></span><br><span class="line">         <span class="keyword">while</span> (*exp&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; *exp&lt;=<span class="string">&#x27;9&#x27;</span>)      <span class="comment">//判定为数字字符</span></span><br><span class="line">         &#123;      postexp[i++]=*exp;</span><br><span class="line">  exp++;</span><br><span class="line">         &#125;</span><br><span class="line">         postexp[i++]=<span class="string">&#x27;#&#x27;</span>;<span class="comment">//用#标识一个数值串结束</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(Optr))<span class="comment">//此时exp扫描完毕，栈不空时循环</span></span><br><span class="line">        &#123;     <span class="built_in">Pop</span>(Optr，e);<span class="comment">//出栈元素e</span></span><br><span class="line">postexp[i++]=e;<span class="comment">//将e存放到postexp中</span></span><br><span class="line">        &#125;</span><br><span class="line">        postexp[i]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//给postexp表达式添加结束标识</span></span><br><span class="line">        <span class="built_in">DestroyStack</span>(Optr);<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)后缀表达式求值<br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-19-24.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">compvalue</span><span class="params">(<span class="type">char</span> *postexp)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="type">double</span> d， a， b， c， e;</span><br><span class="line">        SqStack1 *Opnd;<span class="comment">//定义操作数栈</span></span><br><span class="line">        <span class="built_in">InitStack1</span>(Opnd);<span class="comment">//初始化操作数栈</span></span><br><span class="line">        <span class="keyword">while</span> (*postexp!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//postexp字符串未扫描完时循环</span></span><br><span class="line">        &#123; <span class="keyword">switch</span> (*postexp)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//判定为&#x27;+&#x27;号</span></span><br><span class="line">          <span class="built_in">Pop1</span>(Opnd，a);<span class="comment">//出栈元素a</span></span><br><span class="line">          <span class="built_in">Pop1</span>(Opnd，b);<span class="comment">//出栈元素b</span></span><br><span class="line">          c=b+a;<span class="comment">//计算c</span></span><br><span class="line">          <span class="built_in">Push1</span>(Opnd，c);<span class="comment">//将计算结果c进栈</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="comment">//判定为&#x27;-&#x27;号</span></span><br><span class="line">        <span class="built_in">Pop1</span>(Opnd，a);<span class="comment">//出栈元素a</span></span><br><span class="line">        <span class="built_in">Pop1</span>(Opnd，b);<span class="comment">//出栈元素b</span></span><br><span class="line">        c=b-a;<span class="comment">//计算c</span></span><br><span class="line">        <span class="built_in">Push1</span>(Opnd，c);<span class="comment">//将计算结果c进栈</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="comment">//判定为&#x27;*&#x27;号</span></span><br><span class="line">       <span class="built_in">Pop1</span>(Opnd，a);<span class="comment">//出栈元素a</span></span><br><span class="line">       <span class="built_in">Pop1</span>(Opnd，b);<span class="comment">//出栈元素b</span></span><br><span class="line">       c=b*a;<span class="comment">//计算c</span></span><br><span class="line">       <span class="built_in">Push1</span>(Opnd，c);<span class="comment">//将计算结果c进栈</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="comment">//判定为&#x27;/&#x27;号</span></span><br><span class="line">       <span class="built_in">Pop1</span>(Opnd，a);<span class="comment">//出栈元素a</span></span><br><span class="line">       <span class="built_in">Pop1</span>(Opnd，b);<span class="comment">//出栈元素b</span></span><br><span class="line">       <span class="keyword">if</span> (a!=<span class="number">0</span>)</span><br><span class="line">       &#123;c=b/a;<span class="comment">//计算c</span></span><br><span class="line"><span class="built_in">Push1</span>(Opnd，c);<span class="comment">//将计算结果c进栈</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;<span class="built_in">printf</span>(<span class="string">&quot;\n\t除零错误!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//异常退出</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;<span class="keyword">default</span>:<span class="comment">//处理数字字符</span></span><br><span class="line">       d=<span class="number">0</span>;<span class="comment">//转换成对应的数值存放到d中</span></span><br><span class="line">      <span class="keyword">while</span> (*postexp&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; *postexp&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">      &#123;d=<span class="number">10</span>*d+*postexp-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">postexp++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Push1</span>(Opnd，d);<span class="comment">//将数值d进栈</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">postexp++;<span class="comment">//继续处理其他字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">GetTop1</span>(Opnd，e);<span class="comment">//取栈顶元素e</span></span><br><span class="line">        <span class="built_in">DestroyStack1</span>(Opnd);<span class="comment">//销毁栈</span></span><br><span class="line">        <span class="keyword">return</span> e;<span class="comment">//返回e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)主函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="type">char</span> exp[]=<span class="string">&quot;(56-20)/(4+2)&quot;</span>;   <span class="comment">//可将exp改为键盘输入</span></span><br><span class="line">        <span class="type">char</span> postexp[MaxSize];</span><br><span class="line">        <span class="built_in">trans</span>(exp，postexp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;中缀表达式:%s\n&quot;</span>，exp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;后缀表达式:%s\n&quot;</span>，postexp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表达式的值:%g\n&quot;</span>，<span class="built_in">compvalue</span>(postexp));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例题4-用栈求解迷宫问题"><a href="#例题4-用栈求解迷宫问题" class="headerlink" title="例题4 用栈求解迷宫问题"></a>例题4 用栈求解迷宫问题</h3><p>给定一个M×N的迷宫图、入口与出口、行走规则。求一条从指定入口到出口的路径。<br>        所求路径必须是简单路径，即路径不重复。</p><blockquote><p>在算法中用到的栈采用顺序栈存储结构，即将栈定义为：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;     <span class="type">int</span> i;<span class="comment">//当前方块的行号</span></span><br><span class="line">      <span class="type">int</span> j;<span class="comment">//当前方块的列号</span></span><br><span class="line">      <span class="type">int</span> di;<span class="comment">//di是下一可走相邻方位的方位号</span></span><br><span class="line">&#125;   Box;<span class="comment">//定义方块类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;    Box data[MaxSize];</span><br><span class="line">      <span class="type">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;  StType;</span><br></pre></td></tr></table></figure><p>(1)用栈求一条迷宫路径的算法： （xi，yi）到（xe，ye）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mgpath</span><span class="params">(<span class="type">int</span> xi,<span class="type">int</span> yi,<span class="type">int</span> xe,<span class="type">int</span> ye)</span><span class="comment">//求解路径为:(xi,yi)-&gt;(xe,ye)</span></span></span><br><span class="line"><span class="function"></span>&#123;    Box path[MaxSize], e;  <span class="type">int</span> i,j,di,i1,j1,k;   <span class="type">bool</span> find;</span><br><span class="line">      StType *st;<span class="comment">//定义栈st</span></span><br><span class="line">      <span class="built_in">InitStack</span>(st);<span class="comment">//初始化栈顶指针</span></span><br><span class="line">      e.i=xi; e.j=yi; e.di=<span class="number">-1</span>;<span class="comment">//设置e为入口</span></span><br><span class="line">      <span class="built_in">Push</span>(st,e);<span class="comment">//方块e进栈</span></span><br><span class="line">      mg[xi][yi]=<span class="number">-1</span>;<span class="comment">//入口的迷宫值置为-1避免重复走到该方块</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st))<span class="comment">//栈不空时循环</span></span><br><span class="line">&#123;      <span class="built_in">GetTop</span>(st,e);<span class="comment">//取栈顶方块e</span></span><br><span class="line">        i=e.i; j=e.j; di=e.di;</span><br><span class="line">        <span class="keyword">if</span> (i==xe &amp;&amp; j==ye)<span class="comment">//找到了出口,输出该路径</span></span><br><span class="line">        &#123; <span class="built_in">printf</span>(<span class="string">&quot;一条迷宫路径如下:\n&quot;</span>);</span><br><span class="line"> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(st))</span><br><span class="line">&#123;      <span class="built_in">Pop</span>(st,e);<span class="comment">//出栈方块e</span></span><br><span class="line">       path[k++]=e;<span class="comment">//将e添加到path数组中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (k&gt;=<span class="number">1</span>)</span><br><span class="line">          &#123;     k--;         </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t(%d,%d)&quot;</span>,path[k].i,path[k].j);</span><br><span class="line">                <span class="keyword">if</span> ((k+<span class="number">2</span>)%<span class="number">5</span>==<span class="number">0</span>)  <span class="comment">//每输出每5个方块后换一行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">          <span class="built_in">DestroyStack</span>(st);<span class="comment">//销毁栈</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//输出一条迷宫路径后返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">find=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (di&lt;<span class="number">4</span> &amp;&amp; !find)   <span class="comment">//找相邻可走方块(i1,j1)</span></span><br><span class="line">      &#123;di++;</span><br><span class="line"><span class="keyword">switch</span>(di)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:i1=i<span class="number">-1</span>; j1=j;   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:i1=i;   j1=j+<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:i1=i+<span class="number">1</span>; j1=j;   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:i1=i;   j1=j<span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mg[i1][j1]==<span class="number">0</span>)  find=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//找到一个相邻可走方块，设置find为真</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (find)  <span class="comment">//找到了一个相邻可走方块(i1,j1)</span></span><br><span class="line">        &#123;       st-&gt;data[st-&gt;top].di=di;  <span class="comment">//修改原栈顶元素的di值</span></span><br><span class="line">                e.i=i1; e.j=j1; e.di=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">Push</span>(st,e);  <span class="comment">//相邻可走方块e进栈</span></span><br><span class="line">  mg[i1][j1]=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//(i1,j1)迷宫值置为-1避免重复走到该方块</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//没有路径可走,则退栈</span></span><br><span class="line">        &#123;<span class="built_in">Pop</span>(st,e);<span class="comment">//将栈顶方块退栈</span></span><br><span class="line">mg[e.i][e.j]=<span class="number">0</span>;</span><br><span class="line"> <span class="comment">//让退栈方块的位置变为其他路径可走方块</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">DestroyStack</span>(st);<span class="comment">//销毁栈</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表示没有可走路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(2)主函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="keyword">if</span>  (!<span class="built_in">mgpath</span>(<span class="number">1</span>,<span class="number">1</span>,M,N))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该迷宫问题没有解!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>进行插入的一端称为队尾(rear)，进行删除的一端称为队首(front)</p><h2 id="顺序队"><a href="#顺序队" class="headerlink" title="顺序队"></a>顺序队</h2><p>顺序队类型SqQueue定义如下：</p><blockquote><p>typedef struct<br>{     ElemType data[MaxSize]；<br>      int front,rear；      //队首和队尾指针<br>}   SqQueue;</p></blockquote><p><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-19-24.png" alt=""></p><p>队空条件：front = rear<br> 队满条件：rear = MaxSize－1<br> 元素e进队：rear++; data[rear]=e;<br> 元素e出队：front++; e=data[front];</p><h3 id="初始化顺序队"><a href="#初始化顺序队" class="headerlink" title="初始化顺序队"></a>初始化顺序队</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;　  q=(SqQueue *)<span class="built_in">malloc</span> (<span class="built_in">sizeof</span>(SqQueue));</span><br><span class="line">　    q-&gt;front=q-&gt;rear=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁队列"><a href="#销毁队列" class="headerlink" title="销毁队列"></a>销毁队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>(q-&gt;front==q-&gt;rear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进队列"><a href="#进队列" class="headerlink" title="进队列"></a>进队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;        <span class="keyword">if</span> (q-&gt;rear==MaxSize<span class="number">-1</span>)<span class="comment">//队满上溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         q-&gt;rear++;</span><br><span class="line">         q-&gt;data[q-&gt;rear]=e;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q,ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="keyword">if</span> (q-&gt;front==q-&gt;rear)　　<span class="comment">//队空下溢出</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       q-&gt;front++;</span><br><span class="line">       e=q-&gt;data[q-&gt;front];</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-46-01.png" alt=""><br><img src="/img/栈与队列笔记/Snipaste_2022-04-18_11-47-18.png" alt=""><br>这里是通过逻辑方式实现环形队列，也就是将rear++和front++改为：<br>  rear=(rear+1)%MaxSize<br>  front=(front+1)%MaxSize<br><strong>队空条件：front = rear<br> 队满条件：(rear+1)%MaxSize = front<br> 进队e操作：rear=(rear+1)%MaxSize;  将e放在rear处<br> 出队操作：front=(front+1)%MaxSize; 取出front处元素e；</strong> </p><p> 在环形队列中，实现队列的基本运算算法与非环形队列类似，只是改为上述4要素即可。</p><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p><img src="/img/栈与队列笔记/Snipaste_2022-04-18_12-28-34.png" alt=""></p><blockquote><p>单链表中数据结点类型DataNode定义如下：<br>typedef struct qnode<br>{      ElemType data;    //数据元素<br>        struct qnode *next;<br>}  DataNode;</p><p>链队中头结点类型LinkQuNode定义如下：<br>typedef struct<br>{      DataNode <em>front;    //指向单链表队头结点<br>        DataNode </em>rear;     //指向单链表队尾结点<br>}  LinkQuNode; </p></blockquote><p>队空条件：front=rear=NULL<br> 队满条件：不考虑<br> 进队e操作：将包含e的结点插入到单链表表尾<br> 出队操作：删除单链表首数据结点</p><h3 id="初始化链队"><a href="#初始化链队" class="headerlink" title="初始化链队"></a>初始化链队</h3><p>构造一个空队列，即只创建一个链队头结点，其front和rear域均置为NULL，不创建数据元素结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQuNode *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;     q=(LinkQuNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkQuNode));</span><br><span class="line">       q-&gt;front=q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="销毁链队"><a href="#销毁链队" class="headerlink" title="销毁链队"></a>销毁链队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQuNode *&amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;      DataNode *p=q-&gt;front，*r;  <span class="comment">//p指向队头数据结点</span></span><br><span class="line">        <span class="keyword">if</span>  (p!=<span class="literal">NULL</span>)<span class="comment">//释放数据结点占用空间</span></span><br><span class="line">        &#123;      r=p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (r!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;      <span class="built_in">free</span>(p);</span><br><span class="line">       p=r;r=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">free</span>(p);  <span class="built_in">free</span>(q); <span class="comment">//释放链队结点占用空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列是否为空-1"><a href="#判断队列是否为空-1" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQuNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">return</span>(q-&gt;rear==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进链队"><a href="#进链队" class="headerlink" title="进链队"></a>进链队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQueue</span><span class="params">(LinkQuNode *&amp;q，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     DataNode *p;</span><br><span class="line">       p=(DataNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataNode));</span><br><span class="line">       p-&gt;data=e;</span><br><span class="line">       p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">if</span> (q-&gt;rear==<span class="literal">NULL</span>)   <span class="comment">//若链队为空，新结点是队首结点又是队尾结点</span></span><br><span class="line">q-&gt;front=q-&gt;rear=p;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;       q-&gt;rear-&gt;next=p;   <span class="comment">//将*p结点链到队尾，并将rear指向它</span></span><br><span class="line">q-&gt;rear=p;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出链队"><a href="#出链队" class="headerlink" title="出链队"></a>出链队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQuNode *&amp;q，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     DataNode *t;</span><br><span class="line">      <span class="keyword">if</span> (q-&gt;rear==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列为空</span></span><br><span class="line">      t=q-&gt;front;   <span class="comment">//t指向第一个数据结点</span></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;front==q-&gt;rear)  <span class="comment">//队列中只有一个结点时</span></span><br><span class="line">q-&gt;front=q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">//队列中有多个结点时</span></span><br><span class="line">q-&gt;front=q-&gt;front-&gt;next;</span><br><span class="line">      e=t-&gt;data;</span><br><span class="line">      <span class="built_in">free</span>(t);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构笔记 </tag>
            
            <tag> 线性栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程从入门到实践</title>
      <link href="/2022/04/08/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/08/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>使用python安装库，先cd到pip所在目录下，再用.\pip install 安装所需要的库</p><h1 id="变量和简单的数据类型"><a href="#变量和简单的数据类型" class="headerlink" title="变量和简单的数据类型"></a>变量和简单的数据类型</h1><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>name.upper()</strong>:将字符串全部改为大写</p><p><strong>name.lower()</strong>:将字符串全部改为小写</p><p><strong>name.title()</strong>:将空格后的首字母大写</p><p><strong>f字符串</strong>:在字符串中使用变量的值，例如first_name=”asda”   last_name=”love” 则full_name=f”{first_name} {last_name}”<br>当然f变量中也可直接加字符,例如message=f”Hello,{full_name.title()}!”</p><p><strong>制表符与换行符</strong>:\t制表符（占位4个字母）\n换行符</p><p><strong>favorite.rstrip()</strong>:删除字符串末尾多余空白  <strong>.lstrip()</strong>:删除开头空白 <strong>.strip()</strong>:删除字符串两端空白</p><h2 id="数"><a href="#数" class="headerlink" title="数"></a>数</h2><p>Python中使用**表示乘方运算<br>在书写很大的数时，可以使用下划线将数字分组,例如universe_age=14_000_000_000 python不会打印其中下划线</p><h2 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h2><p>例如定义bicycles=[‘trek’,’cannondale’,’redline’,’specialized’]<br>则bicycles[1]是’cannondale’ &ensp; bicycles[-1]是’specialized’</p><p><strong>.append()</strong>:可以在列表末尾添加元素,例如 bicycles.append(‘giant’)可将’giant’添加到列表末尾</p><p><strong>.insert(a,s)</strong>：表示在列表的a位置插入s元素</p><p><strong>del bicycles[1]</strong>:即删除列表bicycles的第二个元素</p><p><strong>bicycles.pop()</strong>:可以弹出列表的最后一个元素 &ensp; 也可用 <strong>.pop(a)</strong>弹出任意一个元素</p><p><strong>bicycles.remove(‘reline’)</strong>: 可以删除列表中指定元素的值（注意当相同的值有多个时，只删除第一个）</p><p><strong>.sort()</strong>: 可以永久性地修改列表的排列顺序 &ensp;若只想临时排序而不想更改原列表的值，可以用 <strong>.sorted()</strong>  &emsp; 若想要反向排序，可用 <strong>.sort(reverse=True)</strong></p><p><strong>.reverse()</strong>:反转列表</p><p><strong>len()</strong>:获取列表长度</p><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><p>最简单的利用for循环打印所有名字</p><blockquote><p>magicians</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB学习笔记</title>
      <link href="/2022/04/07/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/07/Matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>生成等步长的行向量：<br>a=m:p:n(m,p,n分别代表初值，步长和终值)，也可用linspace（a,b,n)但这里表示将区间(a,b)分为n-1等分<br>可以利用维数相同的行向量拼接为矩阵：例如C=[c1;c2]<br><strong>B(i:j)</strong>:若B是向量，表示B中第i个分量至第j个分量构成的新向量；<br>若B为矩阵，例如B=[1,2,3;4,5,6;7,8,9]<br>B1=B(1:2,2:3)=[2 3;5 6]<br>(表示将第1行至第2行，第2列至第3列的元素所构成矩阵赋值给B1）<br>B2=B(:,2:3) 表示将第二列至第三列构成的子矩阵赋值给B2</p><p>生成多项式：<strong>poly2sym(P)</strong> 若r=[r1,r2,r3,r4…]是多项式的全部根构成的集合，可用poly(r) 返回多项式的系数，进而可用poly2sym生成多项式；若A是n*n多项式，则poly(A)返回的A的特征多项式的n+1个系数</p><p>多项式的乘法：<strong>conv(p1,p2);</strong> (这里p1,p2是系数向量)</p><p>多项式的除法:<strong>[u,v]=deconv(p1,p2)</strong> (这里u和v分别储存商和余数)</p><p>多项式的导数和根:<strong>p1=polyder(P)</strong> (这里p1，p2均是系数矩阵) <br> <strong>roots(p)</strong></p><p>多项式的求值：<strong>polyval(p,x)</strong>(这里x可以是想要求的所有$x_i$所构成的向量)</p><p>定义匿名函数:例如 g=@(x) x.^2+8 定义了函数$x^2+8$<br>f1=@(x,y)x.^3 +y.^3 定义了函数$x^3+y^3$<br>例：设函数$f(x,y,z)=xcos^2y+x^3siny+xyz$,求x=2,y=$\frac{\pi}{4}$,z=1时f的值<br>程序如下：<code>ff=@(x,y,z)x*(cos(y))^2+x^3*sin(y)+x*y*z;</code><br><code>f=ff(2,pi/4,1);</code></p><p><strong>画函数图像</strong>：<strong>fplot(f,[a,b])</strong> 可画出f(x)在[a,b]上的图像<br>用<strong>grid</strong>可添加坐标网络<br>可用 <strong>fzero(f,[a,b])</strong> 求f在区间[a,b]的零点(注意这里区间两端点对应f的值必须异号，否则会报错)或用 <strong>fzero(f,c)</strong> 求f在c附近的零点</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛顿插值&amp;三次样条&amp;切比雪夫&amp;观察龙格现象</title>
      <link href="/2022/04/06/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC&amp;%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1&amp;%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB&amp;%E8%A7%82%E5%AF%9F%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1/"/>
      <url>/2022/04/06/%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC&amp;%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1&amp;%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB&amp;%E8%A7%82%E5%AF%9F%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>这次数值分析报告如下，要求是用MATLAB实现构建牛顿插值多项式，三次样条插值多项式，切比雪夫零点构成的多项式并观察在牛顿插值多项式高次情形下的龙格现象(虽然MATLAB里有成熟的插值工具，但自己掌握思想后实现一遍总归是没有坏处的吧，我想）<br>感觉MATLAB不用main函数的话写函数要同时开好多个窗口好麻烦的说。。。最近各种事情忙得昏天黑地，不过每天也过得很充实，还发现了新神作《文学少女》(后悔高考前没遇到文少，不然我高考语文肯定还能提10分，确信)，看啥时候有空写个书评吧（笑）<br><div class="row">    <embed src="https://ckl-ruby.xyz/file/Newton.pdf" width="100%" height="550" type="application/pdf"></div></p>]]></content>
      
      
      <categories>
          
          <category> Mathmatics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 数值分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的一些常用技巧</title>
      <link href="/2022/03/30/C++%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/30/C++%E5%B8%B8%E7%94%A8%E5%BA%93%E5%8F%8A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-常用头文件"><a href="#C-常用头文件" class="headerlink" title="C++常用头文件"></a>C++常用头文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// C++基本库，有输入输出函数cout, cin, scanf,printf，min, max, swap</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> <span class="comment">// 包含了原来C语言中的stdio.h头文件，C++中好像被iostream代替了</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含了C++特有的string类型用于字符串储存，相比C中的</span></span></span><br><span class="line"><span class="type">char</span>有很多好用的功能</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 包含了各种算法，如：sort, max, min, lower_bound,upper_bound, find</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> <span class="comment">// map数据结构，即一种映射，可代替hash表（底层红黑树）</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> <span class="comment">// set数据结构，即一个集合，可存储不重复的数据类型（底层红黑树）</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// 队列数据结构</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">// 栈数据结构</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// 动态数组，十分有用的数据结构，可以代替数组使用</span></span></span><br></pre></td></tr></table></figure><h1 id="常用函数与数据结构"><a href="#常用函数与数据结构" class="headerlink" title="常用函数与数据结构"></a>常用函数与数据结构</h1><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"> cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 1 2</span></span><br><span class="line"> <span class="built_in">swap</span>(a, b);</span><br><span class="line"> cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出 2 1</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>头文件：<code>#include&lt;algorithm&gt;</code><br>将一个数组进行排序，有两个必须参数，数组的开头指针，数组的结尾指针，默认为升序，如果想改为降序，可通过加入第三个参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *a)</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"> cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line"> <span class="built_in">sort</span>(a, a + <span class="number">5</span>);</span><br><span class="line"> <span class="built_in">print</span>(a); <span class="comment">// 输出 1 2 3 4 5</span></span><br><span class="line"> <span class="built_in">sort</span>(a, a + <span class="number">5</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"> <span class="comment">// greater&lt;int&gt;() 表示排序对象为int，升序</span></span><br><span class="line"> <span class="comment">// 降序为 less&lt;int&gt;()</span></span><br><span class="line"> <span class="built_in">print</span>(a); <span class="comment">// 输出 5 4 3 2 1</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>头文件：<code>#include &lt;queue&gt;</code><br>常用的队列由 queue：普通队列；dequeue：双端队列；priority_queue：优先队列。<br>这里只给出普通队列的一些常用操作：<br>• <code>queue&lt;int&gt; q</code>; 创建队列，队列中元素为 int 类型<br>• <code>q.push(1)</code>; 向队尾加入元素 1<br>• <code>q.front()</code>; 查询队首元素<br>• <code>q.pop()</code>; 弹出队首元素<br>• <code>q.size()</code>; 查询队列大小<br>• <code>q.empty()</code>; 队列为空返回 true，非空返回 false<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 创建一个数据类型为int的队列，命名为q</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 向队尾加入元素1</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>); <span class="comment">// 向队尾加入元素4</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>); <span class="comment">// 向队尾加入元素2</span></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 输出当前队列大小</span></span><br><span class="line"><span class="comment">// 用于判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;empty!!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;non-empty!!&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">// 判断队列不为空</span></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// q.front() 取出队首元素</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 出队，将队首元素弹出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">non-empty!!</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>头文件：<code>#include &lt;stack&gt;</code><br>栈的功能用法和队列比较相似。这里只给出普通队列的一些常用操作：<br>• <code>stack&lt;int&gt; stk</code>; 创建栈 stk，栈中元素为 int 类型<br>• <code>stk.push(1)</code>; 向栈顶加入元素 1<br>• <code>stk.top()</code>; 查询栈顶元素<br>• <code>q.pop()</code>; 弹出栈顶元素<br>• <code>q.size()</code>; 查询栈的大小<br>• <code>q.empty()</code>; 若栈为空返回 true，非空返回 false<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">stk.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; stk.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; stk.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">stk.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>头文件：<code>#include &lt;vector&gt;</code><br>vector这个东西非常强，它可以完全代替数组，而且和栈有完全相同的功能，甚至更强，比如我们想通过用户输入的值 N 来开辟一个大小为 N 的数组，原来只能通过分配内存的方法做到，而且还要考虑将内存何时释放的问题，但是动态数组 vector 就完全不用考虑这么多，随便创建，自动释放内存，随意扩容，取值写法和数组完全相同，<br>下面给出几个基础的用法：<br>创建方式有三种，如果变量后面有括号且括号中只有一个变量，则根据括号中的变量大小确定数组的大小且赋值为 0，如果里面有两个变量，则第一个为数组的大小，第二个为数组中的值，如果没有括号，则是空的动态数组，可以通过向其中插入数值扩充数组。<br>• <code>vector&lt;int&gt; a</code>; 创建一个空的动态数组 a<br>• <code>vector&lt;int&gt; v(10)</code>; 创建一个大小为 10 初始值均为 0 的 int 型数据的动态数组v<br>• <code>vector&lt;int&gt; v(5, 2)</code>; 创建一个大小为 5 初始值均为 2 的 int 型数据的动态数组v<br>• <code>a.push_back(1)</code>; 向 a 的尾部插入元素 1<br>• <code>cout « a[0]</code>; 输出 a 中第 0 个元素<br>• <code>a.size()</code>; 查询数组的当前大小<br>• <code>a.empty()</code>; 若 a 为空则返回 true，否则返回 false<br>• <code>a.erase(a.begin()+2)</code>; 删去数组中第 2 个元素（下标从 0 开始）<br>动态数组中有迭代器这个概念，这个比较抽象（有点类似于指针），可以自行去学习下，<br>它们分别为<br>• <code>a.begin()</code>; 返回指向 a 开头元素的迭代器<br>• <code>a.end()</code>; 返回指向 a 尾部元素的迭代器<br>类似于数组排序，结构体排序写法更加直接<br>• <code>sort(a.begin(), a.end())</code>; 对 a 进行排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>; <span class="comment">//创建一个初始大小为2，初始值均为4的动态数组v</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">//向动态数组v中加入元素3</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>); <span class="comment">//向动态数组v中加入元素2</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//向动态数组v中加入元素1</span></span><br><span class="line"><span class="type">int</span> n = v.<span class="built_in">size</span>(); <span class="comment">//获取当前数组大小</span></span><br><span class="line"><span class="comment">//直接通过遍历数组，输出数组中的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//这里给一个很好用的遍历数组的方法，C++特有，C11引入的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">//删去数组中第2个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//对数组进行从小到大排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">4 4 3 2 1</span></span><br><span class="line"><span class="comment">4 4 3 2 1</span></span><br><span class="line"><span class="comment">4 4 2 1</span></span><br><span class="line"><span class="comment">1 2 4 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构线性表笔记</title>
      <link href="/2022/03/27/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/27/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><hr><p>定义一个data数组来存储线性表的所有元素，再定义一个整型变量length来存储线性表的实际长度，用结构体SqList表示如下：</p><blockquote><p>typedef struct<br> {     ElemType data[MaxSize];<br>        int length;<br>} SqList;    //顺序表类型  </p></blockquote><p>(注:ElemType是自定义类型语句，例如定义为int类型可用 ==typedef int ElemType==)</p><h2 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h2><h3 id="CreateList-SqList-amp-L，ElemType-a-，int-n"><a href="#CreateList-SqList-amp-L，ElemType-a-，int-n" class="headerlink" title="CreateList(SqList *&amp;L，ElemType a[]，int n)"></a>CreateList(SqList *&amp;L，ElemType a[]，int n)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateList</span><span class="params">(SqList *&amp;L，ElemType a[]，<span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function">　　<span class="comment">//整体建立顺序表</span></span></span><br><span class="line"><span class="function"> </span>&#123;     <span class="type">int</span> i;</span><br><span class="line">       L=(SqList *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqList));</span><br><span class="line">       <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  L-&gt;data[i]=a[i];</span><br><span class="line">       L-&gt;length=n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注：输出型参数均用&amp;</p><h3 id="InitList-amp-L"><a href="#InitList-amp-L" class="headerlink" title="InitList(&amp;L)"></a>InitList(&amp;L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;      L=(SqList *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SqList));</span><br><span class="line">　　　　　<span class="comment">//分配存放线性表的顺序表空间</span></span><br><span class="line">       L-&gt;length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DestroyList-amp-L"><a href="#DestroyList-amp-L" class="headerlink" title="DestroyList(&amp;L)"></a>DestroyList(&amp;L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(SqList *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="built_in">free</span>(L);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="Listempty-L"><a href="#Listempty-L" class="headerlink" title="Listempty(L)"></a>Listempty(L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">ListEmpty</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>(L-&gt;length==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListinsertListLength-L"><a href="#ListinsertListLength-L" class="headerlink" title="ListinsertListLength(L)"></a>ListinsertListLength(L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">ListEmpty</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>(L-&gt;length==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispList-L"><a href="#DispList-L" class="headerlink" title="DispList(L)"></a>DispList(L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ListEmpty</span>(L)) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt; L-&gt;length;i++)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>，L-&gt;data[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="GetElem（L-i-amp-e"><a href="#GetElem（L-i-amp-e" class="headerlink" title="GetElem（L,i,&amp;e)"></a>GetElem（L,i,&amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(SqList *L，<span class="type">int</span> i，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">       <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="LocateElem-L-e"><a href="#LocateElem-L-e" class="headerlink" title="LocateElem(L,e)"></a>LocateElem(L,e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList *L， ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i&lt; L-&gt;length &amp;&amp; L-&gt;data[i]!=e)  </span><br><span class="line">            i++;</span><br><span class="line">      <span class="keyword">if</span> (i&gt;=L-&gt;length)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span>  <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若找到，则返回是线性表的第几个数；若找不到，则返回0</p><h3 id="ListInsert-amp-L-i-e"><a href="#ListInsert-amp-L-i-e" class="headerlink" title="ListInsert(&amp;L,i,e)"></a>ListInsert(&amp;L,i,e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">ListInsert</span><span class="params">(SqList *&amp;L，<span class="type">int</span> i，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> j;</span><br><span class="line">       <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//参数错误时返回false</span></span><br><span class="line">       i--;<span class="comment">//将顺序表逻辑序号转化为物理序号</span></span><br><span class="line">       <span class="keyword">for</span> (j=L-&gt;length;j&gt;i;j--)<span class="comment">//将data[i..n]元素后移一个位置</span></span><br><span class="line">L-&gt;data[j]=L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">      L-&gt;data[i]=e;<span class="comment">//插入元素e</span></span><br><span class="line">      L-&gt;length++;<span class="comment">//顺序表长度增1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//成功插入返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListDelete-amp-L-i-amp-e"><a href="#ListDelete-amp-L-i-amp-e" class="headerlink" title="ListDelete(&amp;L,i,&amp;e)"></a>ListDelete(&amp;L,i,&amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList *&amp;L，<span class="type">int</span> i，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="type">int</span> j;</span><br><span class="line">       <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)　<span class="comment">//参数错误时返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       i--;<span class="comment">//将顺序表逻辑序号转化为物理序号</span></span><br><span class="line">       e=L-&gt;data[i];</span><br><span class="line">       <span class="keyword">for</span> (j=i;j&lt;L-&gt;length<span class="number">-1</span>;j++)  <span class="comment">//将data[i..n-1]元素前移</span></span><br><span class="line">L-&gt;data[j]=L-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">      L-&gt;length--;  <span class="comment">//顺序表长度减1</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//成功删除返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul><li><p>例1.设顺序表L有10个整数。设计一个算法，以第一个元素为分界线（基准），将所有小于等于它的元素移到该元素的前面，将所有大于它的元素移到该元素的后面。</p><blockquote><p>思路：类似快排思路，利用双指针从两头寻找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move1</span><span class="params">(SqList *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;      <span class="type">int</span> i=<span class="number">0</span>， j=L-&gt;length<span class="number">-1</span>;  ElemType tmp;</span><br><span class="line">       ElemType pivot=L-&gt;data[<span class="number">0</span>];<span class="comment">//以data[0]为基准</span></span><br><span class="line">       <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">        &#123;<span class="keyword">while</span> (i&lt;j &amp;&amp; L-&gt;data[j]&gt;pivot)</span><br><span class="line">      j--;   <span class="comment">//从后向前扫描，找一个≤pivot的元素</span></span><br><span class="line">               <span class="keyword">while</span> (i&lt;j &amp;&amp; L-&gt;data[i]&lt;=pivot)</span><br><span class="line">      i++;<span class="comment">//从前向后扫描，找一个&gt;pivot的元素</span></span><br><span class="line"><span class="keyword">if</span>  (i&lt;j)</span><br><span class="line">&#123;      tmp=L-&gt;data[i];</span><br><span class="line">        L-&gt;data[i]=L-&gt;data[j];</span><br><span class="line">        L-&gt;data[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=L-&gt;data[<span class="number">0</span>];  </span><br><span class="line">        L-&gt;data[<span class="number">0</span>]=L-&gt;data[j];   L-&gt;data[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1></li></ul><hr><p>单链表中的结点类型LinkNode定义如下：</p><blockquote><p>typedef struct LNode            //定义单链表结点类型<br>{      ElemType data;<br>        struct LNode *next;     //指向后继结点<br>}  LinkNode;</p></blockquote><p>插入和删除结点是单链表中最常见的的两种操作：<br><strong>插入</strong>：1.s-&gt;next = p-&gt;next;</p><pre><code>      2. p-&gt;next = s;</code></pre><p><strong>删除</strong>：1.q=p-&gt;next;</p><ol><li>p-&gt;next=q-&gt;next;</li><li>free(q);</li></ol><h2 id="建立单链表的两种方法"><a href="#建立单链表的两种方法" class="headerlink" title="建立单链表的两种方法"></a>建立单链表的两种方法</h2><p>（1）<strong>头插法</strong>：(链表的结点顺序与逻辑次序相反)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(LinkNode *&amp;L，ElemType a[]，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;    LinkNode *s;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     L=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">     L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">           <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//循环建立数据结点</span></span><br><span class="line">      &#123;s=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=a[i];<span class="comment">//创建数据结点*s</span></span><br><span class="line">s-&gt;next=L-&gt;next;<span class="comment">//将*s插在原开始结点之前，头结点之后</span></span><br><span class="line">L-&gt;next=s;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(2)<strong>尾插法</strong>：利用尾指针r<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListR</span><span class="params">(LinkNode *&amp;L，ElemType a[]，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;     LinkNode *s，*r;</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line">       L=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));  <span class="comment">//创建头结点</span></span><br><span class="line">       r=L;<span class="comment">//r始终指向尾结点，开始时指向头结点 </span></span><br><span class="line">      <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//循环建立数据结点</span></span><br><span class="line">      &#123;s=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=a[i];<span class="comment">//创建数据结点*s</span></span><br><span class="line">r-&gt;next=s;<span class="comment">//将*s插入*r之后</span></span><br><span class="line">r=s;</span><br><span class="line">      &#125;</span><br><span class="line">      r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点next域置为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><h3 id="InitList-LinkNode-amp-L"><a href="#InitList-LinkNode-amp-L" class="headerlink" title="InitList(LinkNode *&amp;L)"></a>InitList(LinkNode *&amp;L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">        L=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));    <span class="comment">//创建头结点</span></span><br><span class="line">        L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="DestroyList-LinkNode-amp-L"><a href="#DestroyList-LinkNode-amp-L" class="headerlink" title="DestroyList(LinkNode *&amp;L)"></a>DestroyList(LinkNode *&amp;L)</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">        LinkNode *pre=L， *p=L-&gt;next;    <span class="comment">//pre指向*p的前驱结点</span></span><br><span class="line">           <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)<span class="comment">//扫描单链表L</span></span><br><span class="line">      &#123;      <span class="built_in">free</span>(pre);<span class="comment">//释放*pre结点</span></span><br><span class="line">             pre=p;<span class="comment">//pre、p同步后移一个结点</span></span><br><span class="line">             p=pre-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(pre);     <span class="comment">//循环结束时，p为NULL，pre指向尾结点，释放它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListEmpty-LinkNode-L"><a href="#ListEmpty-LinkNode-L" class="headerlink" title="ListEmpty(LinkNode *L)"></a>ListEmpty(LinkNode *L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListEmpty</span><span class="params">(LinkNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">return</span>(L-&gt;next==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListLength-LinkNode-L"><a href="#ListLength-LinkNode-L" class="headerlink" title="ListLength(LinkNode *L)"></a>ListLength(LinkNode *L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(LinkNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  　<span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">　  LinkNode *p=L;<span class="comment">//p指向头结点，n置为0（即头结点的序号为0）</span></span><br></pre></td></tr></table></figure><h3 id="DispList-LinkNode-L"><a href="#DispList-LinkNode-L" class="headerlink" title="DispList(LinkNode *L)"></a>DispList(LinkNode *L)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">(LinkNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       LinkNode *p=L-&gt;next;<span class="comment">//p指向开始结点</span></span><br><span class="line">       <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)<span class="comment">//p不为NULL，输出*p结点的data域</span></span><br><span class="line">       &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>，p-&gt;data);</span><br><span class="line">p=p-&gt;next;<span class="comment">//p移向下一个结点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetElem-LinkNode-L，int-i，ElemType-amp-e"><a href="#GetElem-LinkNode-L，int-i，ElemType-amp-e" class="headerlink" title="GetElem(LinkNode *L，int i，ElemType &amp;e)"></a>GetElem(LinkNode *L，int i，ElemType &amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LinkNode *L，<span class="type">int</span> i，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">     LinkNode *p=L; <span class="comment">//p指向头结点，j置为0（即头结点的序号为0）</span></span><br><span class="line">     <span class="keyword">while</span> (j&lt;i &amp;&amp; p!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//不存在第i个数据结点，返回false</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//存在第i个数据结点，返回true</span></span><br><span class="line">     &#123;       e=p-&gt;data;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocateElem-LinkNode-L，ElemType-e"><a href="#LocateElem-LinkNode-L，ElemType-e" class="headerlink" title="LocateElem(LinkNode *L，ElemType e)"></a>LocateElem(LinkNode *L，ElemType e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(LinkNode *L，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">     LinkNode *p=L-&gt;next;<span class="comment">//p指向开始结点，i置为1  </span></span><br><span class="line">   <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data!=e) </span><br><span class="line">     &#123;     p=p-&gt;next;  <span class="comment">//查找data值为e的结点，其序号为i</span></span><br><span class="line">            i++;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//不存在元素值为e的结点，返回0</span></span><br><span class="line">           <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//存在元素值为e的结点，返回其逻辑序号i</span></span><br><span class="line">          <span class="built_in">return</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListInsert-amp-L，i，e"><a href="#ListInsert-amp-L，i，e" class="headerlink" title="ListInsert(&amp;L，i，e)"></a>ListInsert(&amp;L，i，e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkNode *&amp;L，<span class="type">int</span> i，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　 <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">      LinkNode *p=L，*s;          <span class="comment">//p指向头结点，j置为0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j&lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//未找到第i-1个结点，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//找到第i-1个结点*p，插入新结点并返回true</span></span><br><span class="line">     &#123;</span><br><span class="line">s=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=e;<span class="comment">//创建新结点*s，其data域置为e</span></span><br><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//将*s插入到*p之后</span></span><br><span class="line">p-&gt;next=s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListDelete-amp-L，i，-amp-e"><a href="#ListDelete-amp-L，i，-amp-e" class="headerlink" title="ListDelete(&amp;L，i，&amp;e)"></a>ListDelete(&amp;L，i，&amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkNode *&amp;L，<span class="type">int</span> i，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　 <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">      LinkNode *p=L，*q;<span class="comment">//p指向头结点，j置为0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j&lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)<span class="comment">//查找第i-1个结点</span></span><br><span class="line">      &#123;j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//未找到第i-1个结点，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span><span class="comment">//找到第i-1个结点*p</span></span><br><span class="line">     &#123;q=p-&gt;next;<span class="comment">//q指向第i个结点</span></span><br><span class="line"><span class="keyword">if</span> (q==<span class="literal">NULL</span>)<span class="comment">//若不存在第i个结点，返回false</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">//从单链表中删除*q结点</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放*q结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true表示成功删除第i个结点</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><ul><li><p>例1.设计一个算法，删除一个单链表L中元素值最大的结点（假设最大值结点是唯一的）。<br><img src="/img/线性表笔记/2022-03-30-00-07-15.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delmaxnode</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;      LinkNode *p=L-&gt;next，*pre=L，*maxp=p，*maxpre=pre;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;<span class="keyword">if</span> (maxp-&gt;data&lt;p-&gt;data)<span class="comment">//若找到一个更大的结点</span></span><br><span class="line">&#123;      maxp=p;<span class="comment">//更改maxp</span></span><br><span class="line">       maxpre=pre;<span class="comment">//更改maxpre</span></span><br><span class="line">&#125;</span><br><span class="line">pre=p;<span class="comment">//p、pre同步后移一个结点</span></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       maxpre-&gt;next=maxp-&gt;next;<span class="comment">//删除*maxp结点</span></span><br><span class="line">       <span class="built_in">free</span>(maxp);<span class="comment">//释放*maxp结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例2.有一个带头结点的单链表L（至少有一个数据结点），设计一个算法使其元素递增有序排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(LinkNode *&amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">       LinkNode *p，*pre，*q;</span><br><span class="line">       p=L-&gt;next-&gt;next;<span class="comment">//p指向L的第2个数据结点</span></span><br><span class="line">       L-&gt;next-&gt;next=<span class="literal">NULL</span>;<span class="comment">//构造只含一个数据结点的有序表</span></span><br><span class="line">       <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;q=p-&gt;next;<span class="comment">//q保存*p结点后继结点的指针</span></span><br><span class="line"></span><br><span class="line">pre=L;  <span class="comment">//从有序表开头进行比较，pre指向插入*p的前驱结点</span></span><br><span class="line"><span class="keyword">while</span> (pre-&gt;next!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;next-&gt;data&lt;p-&gt;data)</span><br><span class="line">      pre=pre-&gt;next;<span class="comment">//在有序表中找插入*p的前驱结点*pre</span></span><br><span class="line"></span><br><span class="line">p-&gt;next=pre-&gt;next;</span><br><span class="line">pre-&gt;next=p;</span><br><span class="line">p=q;<span class="comment">//扫描原单链表余下的结点</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1></li></ul><hr><p>双链表中的结点类型DLinkNode定义如下：</p><blockquote><p>typedef struct DNode<br>{<br>       ElemType data;<br>       struct DNode <em>prior;<br>       struct DNode </em>next;<br>} DLinkNode;</p></blockquote><p>在双链表<em>p 结点后插入 </em>s的操作如下：<br>s-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;prior=s;<br>s-&gt;prior=p;<br>p-&gt;next=s;</p><p>在<em>p结点后删除 </em>s的操作如下：<br>p-&gt;next-&gt;next-&gt;prior = p;<br>p-&gt;next = p-&gt;next-&gt;next;</p><h2 id="建立双链表的两种方法"><a href="#建立双链表的两种方法" class="headerlink" title="建立双链表的两种方法"></a>建立双链表的两种方法</h2><p>(1)<strong>头插法</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListF</span><span class="params">(DLinkNode *&amp;L，ElemType a[]，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;　 DLinkNode *s; <span class="type">int</span> i;</span><br><span class="line">       L=(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));<span class="comment">//创建头结点</span></span><br><span class="line">       L-&gt;prior=L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//前后指针域置为NULL</span></span><br><span class="line">       <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//循环建立数据结点</span></span><br><span class="line">       &#123;s=(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">s-&gt;data=a[i];<span class="comment">//创建数据结点*s</span></span><br><span class="line">s-&gt;next=L-&gt;next;<span class="comment">//将*s插入到头结点之后</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;next!=<span class="literal">NULL</span>)      <span class="comment">//若L存在数据结点，修改前驱指针</span></span><br><span class="line">         L-&gt;next-&gt;prior=s;</span><br><span class="line">L-&gt;next=s;</span><br><span class="line">s-&gt;prior=L;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>(2)<strong>尾插法</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateListR</span><span class="params">(DLinkNode *&amp;L，ElemType a[]，<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;     DLinkNode *s，*r;</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line">       L=(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));    <span class="comment">//创建头结点</span></span><br><span class="line">       r=L;<span class="comment">//r始终指向尾结点，开始时指向头结点</span></span><br><span class="line">       <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//循环建立数据结点</span></span><br><span class="line">       &#123;      s=(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">s-&gt;data=a[i];<span class="comment">//创建数据结点*s</span></span><br><span class="line">r-&gt;next=s;s-&gt;prior=r;<span class="comment">//将*s插入*r之后</span></span><br><span class="line">r=s;<span class="comment">//r指向尾结点</span></span><br><span class="line">      &#125;</span><br><span class="line">      r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点next域置为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双链表的基本操作"><a href="#双链表的基本操作" class="headerlink" title="双链表的基本操作"></a>双链表的基本操作</h2><p><strong>与单链表相比，双链表的主要是插入和删除操作不同</strong></p><h3 id="bool-ListInsert-DLinkNode-amp-L，int-i，ElemType-e"><a href="#bool-ListInsert-DLinkNode-amp-L，int-i，ElemType-e" class="headerlink" title="bool ListInsert(DLinkNode *&amp;L，int i，ElemType e)"></a>bool ListInsert(DLinkNode *&amp;L，int i，ElemType e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(DLinkNode *&amp;L，<span class="type">int</span> i，ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;　<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">　  DLinkNode *p=L，*s;      <span class="comment">//p指向头结点，j设置为0</span></span><br><span class="line">      <span class="keyword">while</span> (j&lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)<span class="comment">//查找第i-1个结点</span></span><br><span class="line">      &#123;j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">      &#125;      </span><br><span class="line">            <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//未找到第i-1个结点，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//找到第i-1个结点*p，在其后插入新结点*s</span></span><br><span class="line">      &#123;</span><br><span class="line">s=(DLinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DLinkNode));</span><br><span class="line">s-&gt;data=e;<span class="comment">//创建新结点*s</span></span><br><span class="line">s-&gt;next=p-&gt;next;<span class="comment">//在*p之后插入*s结点</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//若存在后继结点，修改其前驱指针</span></span><br><span class="line">        p-&gt;next-&gt;prior=s;</span><br><span class="line">s-&gt;prior=p;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bool-ListDelete-DLinkNode-amp-L，int-i，ElemType-amp-e"><a href="#bool-ListDelete-DLinkNode-amp-L，int-i，ElemType-amp-e" class="headerlink" title="bool ListDelete(DLinkNode *&amp;L，int i，ElemType &amp;e)"></a>bool ListDelete(DLinkNode *&amp;L，int i，ElemType &amp;e)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(DLinkNode *&amp;L，<span class="type">int</span> i，ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="type">int</span> j=<span class="number">0</span>;   DLinkNode *p=L，*q;  <span class="comment">//p指向头结点，j设置为0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j&lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)  <span class="comment">//查找第i-1个结点</span></span><br><span class="line">      &#123;j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (p==<span class="literal">NULL</span>)<span class="comment">//未找到第i-1个结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">//找到第i-1个结点*p</span></span><br><span class="line">      &#123;q=p-&gt;next;<span class="comment">//q指向第i个结点</span></span><br><span class="line"><span class="keyword">if</span> (q==<span class="literal">NULL</span>)   <span class="comment">//当不存在第i个结点时返回false</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">//从双单链表中删除*q结点</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;next!=<span class="literal">NULL</span>)    <span class="comment">//修改其前驱指针</span></span><br><span class="line">                     p-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);   <span class="comment">//释放*q结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><ul><li>例1.有一个带头结点的双链表L，设计一个算法将其所有元素逆置，即第1个元素变为最后一个元素，第2个元素变为倒数第2个元素，…，最后一个元素变为第1个元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Reverse</span><span class="params">(DLinkNode *&amp;L)</span><span class="comment">//双链表结点逆置</span></span></span><br><span class="line"><span class="function"></span>&#123;     DLinkNode *p=L-&gt;next，*q;<span class="comment">//p指向开好结点</span></span><br><span class="line">      L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//构造只有头结点的双链表L</span></span><br><span class="line">      <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)<span class="comment">//扫描L的数据结点</span></span><br><span class="line">      &#123;q=p-&gt;next;            <span class="comment">//用q保存其后继结点</span></span><br><span class="line"></span><br><span class="line">p-&gt;next=L-&gt;next;<span class="comment">//采用头插法将*p结点插入</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//修改其前驱指针</span></span><br><span class="line">        L-&gt;next-&gt;prior=p;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">p-&gt;prior=L;</span><br><span class="line"></span><br><span class="line">p=q;<span class="comment">//让p重新指向其后继结点</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1>循环单链表即修改尾指针<em>p：p-&gt;next=L;<br>循环双链表则修改头指针</em>L和尾指针 *P: L-&gt;prior=p;p&gt;next=L;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 单链表 </tag>
            
            <tag> 双链表 </tag>
            
            <tag> 数据结构笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex学习笔记</title>
      <link href="/2022/03/25/Latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/25/Latex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Andy&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span><span class="comment">%使得导言区的设置生效</span></span><br><span class="line">hello world!</span><br><span class="line"><span class="comment">%在生成的文档中增加换行，需要在源码中隔一行</span></span><br><span class="line">函数<span class="built_in">$</span>f(x)<span class="built_in">$</span>的定义如下：<span class="built_in">$</span>f(x)=3x<span class="built_in">^</span>2+x-1<span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">函数<span class="built_in">$</span>f(x)<span class="built_in">$</span>的定义如下：<span class="built_in">$</span><span class="built_in">$</span>f(x)=3x<span class="built_in">^</span>2+x-1<span class="built_in">$</span><span class="built_in">$</span>(另起一行）</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="中文处理方法"><a href="#中文处理方法" class="headerlink" title="中文处理方法"></a>中文处理方法</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%导言区</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;<span class="comment">%自定义的新命令</span></span><br><span class="line"><span class="keyword">\newcommand</span><span class="keyword">\degree</span>&#123;<span class="built_in">^</span><span class="keyword">\circ</span>&#125;<span class="comment">%正文区使用了自定义的命令\degree，circ表示一个圆圈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\heiti</span> 勾股定理&#125;<span class="comment">%指定黑体字体</span></span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\kaishu</span> 毕达哥拉斯&#125;<span class="comment">%指定楷书字体</span></span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;<span class="comment">%显示中文需要添加该指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span><span class="comment">%使得导言区的设置生效</span></span><br><span class="line">符号语言表述：设直角三角形<span class="built_in">$</span>ABC<span class="built_in">$</span>,其中<span class="built_in">$</span><span class="keyword">\angle</span> C=90<span class="keyword">\degree</span><span class="built_in">$</span>,则有：</span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125; <span class="comment">%表示带编号的行内公式</span></span><br><span class="line">AB<span class="built_in">^</span>2=BC<span class="built_in">^</span>2+AC<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">AB<span class="built_in">^</span>2=BC<span class="built_in">^</span>2+AC<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h2 id="字体字号设置"><a href="#字体字号设置" class="headerlink" title="字体字号设置"></a>字体字号设置</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[10pt]&#123;article&#125;<span class="comment">%10磅是默认正常的字体大小，即下文中的normalsize</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\myfont</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;<span class="keyword">\textsf</span>&#123;Fancy Text&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">%字体族设置(罗马字体、无衬线字体、打字机字体)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\textrm</span>&#123;Roman Family&#125; <span class="keyword">\textsf</span>&#123;Scan Serif Family&#125;<span class="keyword">\texttt</span>&#123;Typewriter Family&#125;<span class="comment">%\textrm等是字体命令，大括号里是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\rmfamily</span> Roman Family&#125; &#123;<span class="keyword">\sffamily</span> Scan Serif Family&#125;&#123;<span class="keyword">\ttfamily</span> Typewriter Family&#125;<span class="comment">%\rmfamily是字体声明，后面紧跟的文字是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\sffamily</span> Who are you?you find self on everyone around.take you as the same as others!&#125;</span><br><span class="line">&#123;<span class="keyword">\ttfamily</span> Are you aiser than others?&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%字体系列设置(粗细、宽度)，\textbf可以对字体加粗</span></span><br><span class="line"><span class="keyword">\textmd</span>&#123;Medium Series&#125; <span class="keyword">\textbf</span>&#123;Boldface Series&#125;<span class="comment">%\textmd等是字体命令，大括号里是作用到的文字</span></span><br><span class="line">&#123;<span class="keyword">\mdseries</span> Medium Series&#125; &#123;<span class="keyword">\bfseries</span> Boldface Series&#125;<span class="comment">%字体声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%字体形状(直立、斜体、伪斜体、小型大写)</span></span><br><span class="line"><span class="keyword">\textup</span>&#123;Upright Shape&#125; <span class="keyword">\textit</span>&#123;Italic Shape&#125; <span class="comment">%字体命令</span></span><br><span class="line"><span class="keyword">\textsl</span>&#123;Slanted Shape&#125; <span class="keyword">\textsc</span>&#123;Small Caps Shape&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\upshape</span> Upright Shape&#125; &#123;<span class="keyword">\itshape</span> Italic Shape &#125;<span class="comment">%字体声明</span></span><br><span class="line">&#123;<span class="keyword">\slshape</span> Slanted Shape&#125;</span><br><span class="line">&#123;<span class="keyword">\scshape</span> Small Caps Shape&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%中文字体</span></span><br><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125; <span class="keyword">\quad</span>&#123;heiti 黑体&#125;<span class="keyword">\quad</span>&#123;<span class="keyword">\fangsong</span> 仿宋&#125;<span class="keyword">\quad</span> &#123;<span class="keyword">\kaishu</span> 楷书&#125;<span class="comment">%\quad表示空格</span></span><br><span class="line">中文字体的<span class="keyword">\textbf</span>&#123;粗体&#125;与<span class="keyword">\textit</span>&#123;斜体&#125;   (<span class="keyword">\quad</span>表示空格， <span class="keyword">\qquad</span>表示空两格&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%字体大小</span></span><br><span class="line">&#123;<span class="keyword">\tiny</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\scriptsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\footnotesize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\small</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\normalsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\Large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\LARGE</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\huge</span>  Hello &#125;<span class="keyword">\\</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">%中文字号设置命令</span></span><br><span class="line"><span class="keyword">\zihao</span>&#123;5&#125;你好！</span><br><span class="line"><span class="keyword">\myfont</span><span class="comment">%latex格式与内容分离</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\myfont</span>&#125;&#123;texit&#123;textbf&#123;<span class="keyword">\textsf</span>&#123;&#125;&#125;&#125;&#125;</span><br><span class="line">然后在正文中用<span class="keyword">\myfont</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;&#125;表示小节，</span><br><span class="line"><span class="keyword">\subsection</span>&#123;&#125;构建子小节，</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;&#125;构建子子小节</span><br><span class="line">整体如下(换行有<span class="keyword">\\</span>,但不缩进，<span class="keyword">\par</span>可以缩进，文字之间隔一行也可以换行缩进)</span><br><span class="line"></span><br><span class="line"><span class="comment">%文档基本结构</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Andy&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span><span class="comment">%使得导言区的设置生效</span></span><br><span class="line"><span class="keyword">\section</span>&#123;引言&#125;</span><br><span class="line">中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line"></span><br><span class="line">中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\par</span></span><br><span class="line">中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\\</span>中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line"><span class="keyword">\section</span>&#123;实验方法&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;实验结果&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;数据&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;图表&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;实验过程&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;结论&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;致谢&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\chapter</span>&#123;&#125;产生章节，不过要将<span class="keyword">\documentclass</span>&#123;ctexart&#125;改为<span class="keyword">\documentclass</span>&#123;ctexbook&#125;，<span class="keyword">\tableofcontents</span>&#123;&#125;产生目录</span><br><span class="line"><span class="keyword">\\</span>换行但不缩进</span><br><span class="line"><span class="keyword">\par</span><span class="keyword">\ </span>换行且缩进  最常用分段还是插入空行</span><br></pre></td></tr></table></figure><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在英文中，多个空格视为一个空格，中文中空格将被忽略</span><br><span class="line"><span class="keyword">\quad</span> <span class="comment">%产生1em的空白  \qquad  %2em的空白  \, %产生1/6个em的空白  \enspace %产生0.5个em的空白</span></span><br><span class="line"><span class="keyword">\ </span>输出一个空格    <span class="keyword">\kern</span> 1pc 或 <span class="keyword">\ker</span> 1em 产生指定宽度的空格</span><br><span class="line"><span class="comment">%文档基本结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Andy&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;空白符号&#125;</span><br><span class="line">实在学不了唱歌，能把主子伺候好，跟老母亲我一起去淘宝直播 卖宠物用品也是极好的啊，我学生家里就是卖宠物用品的，中日混血，家里有一群猫狗，一墙的仓鼠笼子（我看过照片，大概有几十个的样子）</span><br><span class="line"><span class="keyword">\section</span>&#123;<span class="keyword">\ </span>LaTex 控制符&#125;</span><br><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\&#123;</span>  <span class="keyword">\&#125;</span> <span class="keyword">\~</span>&#123;&#125; <span class="keyword">\_</span>&#123;&#125; <span class="keyword">\^</span>&#123;&#125; <span class="keyword">\textbackslash</span>(这个是输出单斜杠）</span><br><span class="line"><span class="keyword">\section</span>&#123;排版符号&#125;</span><br><span class="line"><span class="keyword">\S</span> <span class="keyword">\P</span> <span class="keyword">\dag</span> <span class="keyword">\ddag</span> <span class="keyword">\copyright</span> <span class="keyword">\pounds</span></span><br><span class="line"><span class="keyword">\section</span>&#123;<span class="keyword">\ </span>Tex 标志符号&#125;</span><br><span class="line"><span class="keyword">\ </span>TeX&#123;&#125; <span class="keyword">\ </span>LaTeX&#123;&#125;  <span class="keyword">\ </span>LaTeXe&#123;&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;引号&#125;</span><br><span class="line">`(左单引号）&#x27;（右单引号） ``（左双引号） &#x27;&#x27; （右双引号）  ``被引号包裹&#x27;&#x27; <span class="comment">%  `表示单引号的左边，&#x27;表示单引号的右边</span></span><br><span class="line"><span class="keyword">\section</span>&#123;连字符&#125;</span><br><span class="line">- -- ---</span><br><span class="line"><span class="keyword">\section</span>&#123;非英文字符&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;重音符号&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="插图问题"><a href="#插图问题" class="headerlink" title="插图问题"></a>插图问题</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figure/&#125;&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">   <span class="keyword">\LaTeX</span>&#123;&#125;中的插图:</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[height=0.5cm]&#123;lion&#125;</span><br><span class="line">   <span class="keyword">\par</span> <span class="keyword">\includegraphics</span>[height=3cm]&#123;ruby&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[scale=0.1]&#123;lion&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[width=3cm]&#123;lion&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[height=0.1<span class="keyword">\textheight</span>]&#123;lion&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[width=0.1<span class="keyword">\textwidth</span>]&#123;lion&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">\includegraphics</span>[angle=-45,height=0.1<span class="keyword">\textheight</span>]&#123;lion&#125; <span class="comment">%顺时针转</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Andy&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l| c| c| c|  r|&#125;<span class="comment">%会有5列，指定每列的居中形式,|表示每列中间有竖线分开</span></span><br><span class="line"><span class="keyword">\hline</span><span class="comment">%每行之间由横线分开</span></span><br><span class="line">姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>加减：$a+b-c$ </p><blockquote><p><code>a+b-c</code></p></blockquote><p>乘法: $a \times b$</p><blockquote><p><code>a\times b (注意\times和b之间要有空格)</code></p></blockquote><p>分数:$\frac{a}{b}$</p><blockquote><p><code>\frac&#123;a&#125;&#123;b&#125;</code></p></blockquote><p>小技巧:对含分式的式子加分号$\left( \frac{a}{b} \right)$ </p><blockquote><p><code>\left( \frac&#123;a&#125;&#123;b&#125; \right)  %这样会比直接写(\frac&#123;a&#125;&#123;b&#125;)好看</code></p></blockquote><p>比较运算: $&lt;, &gt;, \leq, \geq $</p><blockquote><p><code>&lt;, &gt;, \leq, \geq</code></p></blockquote><p>等于，不等于:$=, \not=$</p><blockquote><p><code>=, \not=</code></p></blockquote><p>恒等于（同余）：$\equiv $</p><blockquote><p><code>\equiv</code></p></blockquote><p>$x^a$, $x^{ab}$, $x^ab$</p><blockquote><p><code>x^a, x^&#123;ab&#125;, x^ab %下标原理同上</code></p></blockquote><p>根号与多次方根：$\sqrt a$, $\sqrt[n]a$, $\sqrt[nm]{ab}$</p><blockquote><p><code>\sqrt a, \sqrt[n]a, \sqrt[nm]&#123;ab&#125;</code></p></blockquote><p>花括号:<script type="math/tex">\left\{x_1,x_2\right\}</script></p><blockquote><p><code>\left\&#123;x_1,x_2\right\&#125; (不能直接打花括号，必须要有\left\,\right\)</code></p></blockquote><p>属于、包含与真包含：$\in, \notin, \subset, \subseteq, \supset,\supseteq$</p><blockquote><p><code>\in, \notin, \subset, \subseteq, \supset,\supseteq</code></p></blockquote><p>交，并，补：$\cap, \cup, C_UA, \complement_UA$</p><blockquote><p><code>\cap, \cup, C_UA, \complement_UA</code></p></blockquote><p>省略号和竖线：$\cdot, \cdots,\mid$</p><blockquote><p><code>\cdot, \cdots (一个点与三个点)\mid</code></p></blockquote><p>求和：<script type="math/tex">\sum, \sum_{i=1}^n, \sum_{i=1}^na_i, \sum_{i=1}^{na_i}</script></p><blockquote><p><code>sum, \sum_&#123;i=1&#125;^n, \sum_&#123;i=1&#125;^na_i, \sum_&#123;i=1&#125;^&#123;na_i&#125;(注意在sum后加limits_或nolimits_可以改变求和的位置</code></p></blockquote><p>无穷：$\infty, +\infty, -\infty$</p><blockquote><p><code>\infty, +\infty, -\infty</code></p></blockquote><p>箭头：$\rightarrow, \leftarrow, \uparrow, \downarrow$</p><blockquote><p><code>\rightarrow, \leftarrow, \uparrow, \downarrow</code></p></blockquote><p>极限：<script type="math/tex">\lim, \lim_{x\rightarrow 0}, \lim_{x\rightarrow \infty}</script></p><blockquote><p><code>\lim, \lim_&#123;x\rightarrow 0&#125;, \lim_&#123;x\rightarrow \infty&#125;(注意在lim后加limits_或nolimits_可以改变极限的位置)</code></p></blockquote><p>定积分与不定积分：<script type="math/tex">\int, \int_a^b, \int_{ab}^{cd}</script></p><blockquote><p><code>\int, \int_a^b, \int_&#123;ab&#125;^&#123;cd&#125;</code></p></blockquote><p>二重积分：$\iint, \iint_D$</p><blockquote><p><code>\iint, \iint_D</code></p></blockquote><p>偏导:$\partial$</p><blockquote><p><code>\partial</code></p></blockquote><p>梯度:$\nabla$</p><blockquote><p><code>\nabla</code></p></blockquote><p>对齐：</p><blockquote><p><code>\begin&#123;align&#125;[(n+1)!+k]\operatorname&#123;mod&#125;k &amp;=(n+1)!\operatorname&#123;mod&#125;k+k\operatorname&#123;mod&#125;k\\ &amp;=0+0\\ &amp;=0\end&#123;align&#125;(&#39;&amp;&#39;是对齐)</code></p></blockquote><p>方程组：</p><script type="math/tex; mode=display">\begin{cases}x_1+x_2=2\\ x_1-x_2=0\end{cases}</script><blockquote><p><code>\begin&#123;cases&#125;</code><br><code>x_1+x_2=2</code><br><code>\\ x_1-x_2=0</code><br><code>\end&#123;cases&#125;</code></p></blockquote><p>空格：$a \ b $</p><blockquote><p><code>a \ b (&#39;\ &#39;表示一空格)</code></p></blockquote><p>矩阵与行列式：</p><script type="math/tex; mode=display">\left(\begin{matrix}a &b\\c &d\end{matrix}\right),\left|\begin{matrix}a &b\\c &d\end{matrix}\right|</script><blockquote><p><code>\left(</code><br><code>\begin&#123;matrix&#125;</code><br><code>a &amp;b</code><br><code>\\c &amp;d</code><br><code>\end&#123;matrix&#125;</code><br><code>\right)</code><br><code>,</code><br><code>\left|</code><br><code>\begin&#123;matrix&#125;</code><br><code>a &amp;b</code><br><code>\\c &amp;d</code><br><code>\end&#123;matrix&#125;</code><br><code>\right|</code><br><code>(\left,\right后的符号可替换)</code></p></blockquote><h2 id="自查"><a href="#自查" class="headerlink" title="自查"></a>自查</h2><p><img src="/img/Latex学习笔记/2022-03-28-19-03-43.png" alt=""><br><img src="/img/Latex学习笔记/2022-03-28-19-04-02.png" alt=""><br><img src="/img/Latex学习笔记/2022-03-28-19-08-02.png" alt=""></p><h3 id="字体字形设置"><a href="#字体字形设置" class="headerlink" title="字体字形设置"></a>字体字形设置</h3><p> <img src="/img/Latex学习笔记/2022-03-28-19-08-35.png" alt=""></p><h3 id="常出现式子"><a href="#常出现式子" class="headerlink" title="常出现式子"></a>常出现式子</h3><p> <img src="/img/Latex学习笔记/2022-03-28-19-09-30.png" alt=""><br> <img src="/img/Latex学习笔记/2022-03-28-19-10-06.png" alt=""><br> <img src="/img/Latex学习笔记/2022-03-28-19-10-24.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
